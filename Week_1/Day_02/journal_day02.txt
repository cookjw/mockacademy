Our tasks for Day 2, derived again from [Julie](http://julieatappacademy.tumblr.com/post/67532927993/week-1-day-2) and [Zack](http://zackmdavis.net/blog/2013/09/app-academy-diary-week-one/)'s
blog entries, will be:

- Tic-Tac-Toe

- n-Queens Problem

- Stock Price Problem



Tic-Tac-Toe
------------

My original Python version:

/// Python: tictactoe.py ///

#Tic-Tac-Toe for two players

board = {
(0,0) : "_", (1,0) : "_", (2,0) : "_", (0,1) : "_",
(1,1) : "_", (2,1) : "_", (0,2) : "_", (1,2) : "_", (2,2) : "_",
 }

def horizontalright(square):
    return ((square[0] + 1)%3, square[1])
    
def verticalup(square):
    return (square[0], (square[1] + 1)%3)
    
def diagonalright(square):
    return ((square[0] + 1)%3, (square[1] + 1)%3)
    
def diagonalleft(square):
    return ((square[0] - 1)%3, (square[1] + 1)%3)
    
    
def threeinarow(square):
    if (
    board[square] == board[horizontalright(square)] ==
    board[horizontalright(horizontalright(square))] == "X"
    ) or (
    board[square] == board[horizontalright(square)] == 
    board[horizontalright(horizontalright(square))] == "O"
    ):
        return True
    elif (
    board[square] == board[verticalup(square)] == 
    board[verticalup(verticalup(square))] == "X"
    ) or (
    board[square] == board[verticalup(square)] == 
    board[verticalup(verticalup(square))] == "O"
    ):
        return True
    elif square == (1,1) and (
    (
    board[square] == board[diagonalright(square)] ==
    board[diagonalright(diagonalright(square))] == "X"
    ) or (
    board[square] == board[diagonalright(square)] ==
    board[diagonalright(diagonalright(square))] == "O"
    )
    ):
        return True
    elif square == (1,1) and (
    (
    board[square] == board[diagonalleft(square)] ==
    board[diagonalleft(diagonalleft(square))] == "X"
    ) or (
    board[square] == board[diagonalleft(square)] ==
    board[diagonalleft(diagonalleft(square))] == "O"
    )
    ):
        return True
    else:
        return False
        
def end_condition():
    status = True
    for square in board.keys():
        if threeinarow(square):
            status = True
            print "three in a row for " + str(
            square[0]+1
            ) + " , " + str(square[1]+1)
            break
        elif board[square] == "_":
            status = False
    return status    
    
def printboard():
    print board[(0,2)] + " " + board[(1,2)] + " " + board[(2,2)]
    print board[(0,1)] + " " + board[(1,1)] + " " + board[(2,1)]
    print board[(0,0)] + " " + board[(1,0)] + " " + board[(2,0)]


 
while not end_condition():
    printboard()
    
    
    player1horiz = int(
    raw_input("Player 1 (X) enter horizontal coordinate(1, 2, or 3)\n")
    ) - 1
    player1vert = int(
    raw_input("Player 1 (X) enter vertical coordinate(1, 2, or 3)\n")
    ) - 1    
    player1square = (player1horiz, player1vert)
    while board[player1square] == "X":
        print "Sorry, square already occupied."
        player1horiz = int(
        raw_input(
        "Player 1 (X) enter horizontal coordinate(1, 2, or 3)\n"
        )
        ) - 1
        player1vert = int(
        raw_input(
        "Player 1 (X) enter vertical coordinate(1, 2, or 3)\n"
        )
        ) - 1    
        player1square = (player1horiz, player1vert)
    
    while board[player1square] != "X": 
        if board[player1square] == "_":             
            board[player1square] = "X"
        else:
            print "Sorry, square already occupied."
            player1horiz = int(
            raw_input(
            "Player 1 (X) enter horizontal coordinate(1, 2, or 3)\n"
            )
            ) - 1
            player1vert = int(
            raw_input(
            "Player 1 (X) enter vertical coordinate(1, 2, or 3)\n"
            )
            ) - 1    
            player1square = (player1horiz, player1vert)
    
    printboard()
    
    if end_condition():
        break
    
    player2horiz = int(
    raw_input(
    "Player 2 (O) enter horizontal coordinate(1, 2, or 3)\n"
    )
    ) - 1
    player2vert = int(
    raw_input("Player 2 (O) enter vertical coordinate(1, 2, or 3)\n")
    ) - 1
    player2square = (player2horiz, player2vert) 
    while board[player2square] == "O":
        print "Sorry, square already occupied."    
        player2horiz = int(
        raw_input(
        "Player 2 (O) enter horizontal coordinate(1, 2, or 3)\n"
        )
        ) - 1
        player2vert = int(
        raw_input(
        "Player 2 (O) enter vertical coordinate(1, 2, or 3)\n"
        )
        ) - 1
        player2square = (player2horiz, player2vert)  
    while board[player2square] != "O":    
        if board[player2square] == "_":    
            board[player2square] = "O"  
        else:
            print "Sorry, square already occupied."    
            player2horiz = int(
            raw_input(
            "Player 2 (O) enter horizontal coordinate(1, 2, or 3)\n"
            )
            ) - 1
            player2vert = int(
            raw_input(
            "Player 2 (O) enter vertical coordinate(1, 2, or 3)\n"
            )
            ) - 1
            player2square = (player2horiz, player2vert) 

printboard()
print "Game Over!"


///


Davis-Foster version in Ruby:

/// ///



///


My translation (leaving out the computer-player parts, since these were
unfinished):

///



///


Eight Queens Problem
--------------------

Here, I opted for another kind of translation: from German to English.
Namely, there is a Python solution in the [German Wikipedia article]:

///Python (from German Wikipedia) ///

# Erzeuge eine Liste von Lösung auf einem Brett mit Reihen und Spalten.
# Eine Lösung wird durch eine Liste der Spaltenpositionen,
# indiziert durch die Reihennummer, angegeben.
# Die Indizes beginnen mit Null.
def damenproblem(reihen, spalten):
    if reihen <= 0:
        return [[]] # keine Dame zu setzen; leeres Brett ist Lösung
    else:
        return eine_dame_dazu(reihen - 1, spalten, damenproblem(reihen - 1, spalten))
 
# Probiere alle Spalten, in denen für eine gegebene Teillösung
# eine Dame in "neue_reihe" gestellt werden kann.
# Wenn kein Konflikt mit der Teillösung auftritt,
# ist eine neue Lösung des um eine Reihe erweiterten
# Bretts gefunden.
def eine_dame_dazu(neue_reihe, spalten, vorherige_loesungen):
    neue_loesungen = []
    for loesung in vorherige_loesungen:
        # Versuche, eine Dame in jeder Spalte von neue_reihe einzufügen.
        for neue_spalte in range(spalten):
            # print('Versuch: %s in Reihe %s' % (neue_spalte, neue_reihe))
            if kein_konflikt(neue_reihe, neue_spalte, loesung):
                # Kein Konflikte, also ist dieser Versuch eine Lösung.
                neue_loesungen.append(loesung + [neue_spalte])
    return neue_loesungen
 
# Kann eine Dame an die Position "neue_spalte"/"neue_reihe" gestellt werden,
# ohne dass sie eine der schon stehenden Damen schlagen kann?
def kein_konflikt(neue_reihe, neue_spalte, loesung):
    # Stelle sicher, dass die neue Dame mit keiner der existierenden
    # Damen auf einer Spalte oder Diagonalen steht.
    for reihe in range(neue_reihe):
        if (loesung[reihe]         == neue_spalte              or  # Gleiche Spalte
            loesung[reihe] + reihe == neue_spalte + neue_reihe or  # Gleiche Diagonale
            loesung[reihe] - reihe == neue_spalte - neue_reihe):    # Gleiche Diagonale
                return False
    return True
 
for loesung in damenproblem(8, 8):
    print(loesung)

///

Translated:

/// Python: queenproblem.py ///

# Generate a list of solutions on a board with rows and columns.
# A solution is given by a list of column positions, indicated by 
# row number.
# Indices begin with zero.
def queenproblem(rows, columns):
    if rows <= 0:
        return [[]] # no queen to place; empty board is solution
    else:
        return one_more_queen(rows - 1, columns, queenproblem(rows - 1, columns))
 
# Try all columns in which, for a given partial solution,
# a queen can be placed in "new_row".
# If no conflict with the partial solution occurs,
# a new solution for the board extended by one row
# is found.
def one_more_queen(new_row, columns, previous_solutions):
    new_solutions = []
    for solution in previous_solutions:
        # Attempt to insert a queen in each column of new_row.
        for new_column in range(columns):
            # print('trying: %s in row %s' % (new_column, new_row))
            if no_conflict(new_row, new_column, solution):
                # No conflicts, so this attempt is a solution.
                new_solutions.append(solution + [new_column])
    return new_solutions
 
# Can a queen be placed at position "new_column"/"new_row"
# without attacking the queens already present?
def no_conflict(new_row, new_column, solution):
    # Make sure that the new queen does not occupy a row or diagonal 
    # with any of the existing queens.
    for row in range(new_row):
        # print(solution, row, new_column, new_row)
        if (solution[row]       == new_column              or  # Same column.
            solution[row] + row == new_column + new_row or  # Same diagonal.
            solution[row] - row == new_column - new_row):    # Same diagonal.
                return False
    return True

for solution in queenproblem(8, 8):
    print(solution)


///

Stock Price Problem
-------------------